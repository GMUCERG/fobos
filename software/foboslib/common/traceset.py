##the TracesSet class
##encpsulates a trace and provide utility functions to load/ save traces
import numpy as np

class TraceSet():

   def __init__(self, traceNum, fileName = None, cropStart = 0, cropEnd = 0):
      self.traces = None #two dimentional numpy array to hold traces
      self.traceNum =  traceNum
      # Documentation information saved with traces meta file
      # can be used to document/replicate run. This file is generated by the
      self.sourceScope = 'Unknown' #type of oscillocope used
      self.samplingFreq = 0
      self.samplingResolution = 0
      self.channelRange = 0
      if fileName != None:
         self.readTraceSetFromFile(fileName, cropStart, cropEnd)

   def _adjustSampleSize(self, sampleLength, dataArray):
        #print "\tAdjusting Sample Size to ->" + str(sampleLength)
        temp = dataArray.shape
        newDataArray = dataArray
        arrLen = temp[0]
        #print "Array Length --> " + str(arrLen)
        if (arrLen == sampleLength):
            
            return dataArray
            
        elif (arrLen > sampleLength):
            
            diff = arrLen-sampleLength
            for count in range(0,diff):
                newDataArray = np.delete(newDataArray, -1, 0)
            return newDataArray 
            
        elif (arrLen < sampleLength):
            
            diff = sampleLength-arrLen
            for count in range (0,diff):
                newDataArray = np.append(newDataArray,0)
            return newDataArray 
            
   def _detectSampleSize(self, file_name):
       """
       This function calcualates the number of sample per trace. This is needed to do any paddig/truncation to make all 
       traces the same size. We iterate through the first 10 traces and get the max number of traces
       """
    #    print("DEBUG: Module: analysis, Function: detectSampleSize():")
    #    print("----Detecting samples per trace")
       traceFile = open(file_name, 'r+b')
       maxNumOfSamples = 0
       for traceCount in range (0,10):
           try:
               trace = np.load(traceFile)
           except:
            #    print("----You have less than 10 samples. Max number of samples is : " + str(maxNumOfSamples))
               return maxNumOfSamples
           numOfSamples = len(trace)
           if maxNumOfSamples < numOfSamples:
               maxNumOfSamples = numOfSamples
    #    print("Max number of samples in the first 10 traces is: " + str(maxNumOfSamples))
       traceFile.close()
       return maxNumOfSamples
    
   def readTraceSetFromFile(self, file_name, crop_start = 0, crop_end = 0):
       print("Loading raw traces from file: " + file_name ) 
       print("Please wait ...")
       samples_per_trace = self._detectSampleSize(file_name)
       measurementFile = open(file_name, 'r+b')
       #Get sample size to adjust all traces to the same number of samples. 
       #A better solution is to get the data cleaned up upon acquistion.
       ##create the array
       if crop_end == 0:
         crop_end = samples_per_trace ##0 will mean all samples until the end
       samples_to_read = crop_end - crop_start
       raw_traces = np.empty((self.traceNum, samples_to_read))
       # need to reset file handle since we used it 
       # measurementFile.seek(0)
       for traceCount in range (0,self.traceNum):
           #print "traceCount= " + str(traceCount)
           tempArrayMeasurement = np.load(measurementFile)
           tempArrayMeasurement = self._adjustSampleSize(samples_per_trace, tempArrayMeasurement)
           raw_traces[traceCount,:] = tempArrayMeasurement[crop_start: crop_end]
       #    print(traceCount)
       print("Loading done.")
       self.traces = raw_traces
       #    print(self.traces)
       measurementFile.close()

   def getTraceCount(self):
      if self.traces != None:
         return 0
      else:
         return traces.shape[0]

   def getSamplesPerTrace(self):
      if self.traces != None:
         return 0
      else:
         return traces.shape[1]

